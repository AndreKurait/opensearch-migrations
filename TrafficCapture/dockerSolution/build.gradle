plugins {
    id 'org.opensearch.migrations.java-library-conventions'
    id "com.avast.gradle.docker-compose"
    id 'com.bmuschko.docker-remote-api'
}

import org.opensearch.migrations.common.CommonUtils
import com.bmuschko.gradle.docker.tasks.image.DockerBuildImage

def orchestrationSpecsDir = project.rootProject.file("orchestrationSpecs")
def configProcessorSrc = file("${orchestrationSpecsDir}/packages/config-processor")
def schemasSrc = file("${orchestrationSpecsDir}/packages/schemas")
def stagingDir = file("build/docker/staging/config-processor")

task npmInstall {
    description = 'Install npm dependencies for orchestrationSpecs'

    inputs.file("${orchestrationSpecsDir}/package.json")
    inputs.file("${orchestrationSpecsDir}/package-lock.json")
    outputs.dir("${orchestrationSpecsDir}/node_modules")
    outputs.cacheIf { true }

    doLast {
        exec {
            workingDir orchestrationSpecsDir
            commandLine 'npm', 'ci'
        }
    }
}

task buildSchemas {
    description = 'Build the schemas TypeScript package'
    dependsOn npmInstall

    inputs.dir(schemasSrc)
    inputs.file("${schemasSrc}/package.json")
    inputs.file("${schemasSrc}/tsconfig.json")
    outputs.dir("${schemasSrc}/dist")
    outputs.file("${schemasSrc}/tsconfig.tsbuildinfo")
    outputs.cacheIf { true }

    doLast {
        exec {
            workingDir orchestrationSpecsDir
            commandLine 'npm', 'run', 'build:schemas'
        }
    }
}

task buildConfigProcessor {
    description = 'Build the config-processor TypeScript package'
    dependsOn buildSchemas  // Depends on schemas since it imports them

    inputs.dir("${configProcessorSrc}/src")
    inputs.file("${configProcessorSrc}/package.json")
    inputs.file("${configProcessorSrc}/tsconfig.json")
    outputs.dir("${configProcessorSrc}/dist")
    outputs.cacheIf { true }

    doLast {
        exec {
            workingDir orchestrationSpecsDir
            commandLine 'npm', 'run', 'build', '-w', '@opensearch-migrations/config-processor'
        }
    }
}

task stageConfigProcessor {
    description = 'Stages the config-processor with production dependencies for Docker'
    dependsOn buildConfigProcessor

    // Inputs: built artifacts and package files
    inputs.dir("${configProcessorSrc}/dist")
    inputs.dir("${schemasSrc}/dist")
    inputs.file("${configProcessorSrc}/package.json")
    inputs.file("${schemasSrc}/package.json")

    // Output: the staging directory
    outputs.dir(stagingDir)
    outputs.cacheIf { true }

    doLast {
        // Clean and create staging directory
        delete stagingDir
        stagingDir.mkdirs()

        // Copy built config-processor files
        copy {
            from "${configProcessorSrc}/dist"
            into stagingDir
        }

        // Copy package.json for config-processor
        copy {
            from "${configProcessorSrc}/package.json"
            into stagingDir
        }

        // Create node_modules structure for workspace dependency
        def schemasModuleDir = file("${stagingDir}/node_modules/@opensearch-migrations/schemas")
        schemasModuleDir.mkdirs()

        // Copy built schemas as a local dependency
        copy {
            from "${schemasSrc}/dist"
            into "${schemasModuleDir}/dist"
        }

        copy {
            from "${schemasSrc}/package.json"
            into schemasModuleDir
        }

        // Install production dependencies only
        exec {
            workingDir stagingDir
            commandLine 'npm', 'install', '--omit=dev', '--no-package-lock'
        }

        // Clean up unnecessary files to reduce image size
        delete fileTree("${stagingDir}/node_modules") {
            include '**/.package-lock.json'
            include '**/README.md'
            include '**/LICENSE*'
            include '**/*.map'
            include '**/test/**'
            include '**/tests/**'
            include '**/.github/**'
            include '**/docs/**'
            include '**/example/**'
            include '**/examples/**'
        }

        // Make CLI script executable if it exists
        def cliScript = file("${stagingDir}/cli.js")
        if (cliScript.exists()) {
            cliScript.setExecutable(true)
        }

        // Copy any shell scripts from config-processor
        copy {
            from "${configProcessorSrc}/scripts"
            into "${stagingDir}/scripts"
            include '*.sh'
            fileMode 0755
        }

        logger.lifecycle("âœ“ Staged config-processor to: ${stagingDir}")
        logger.lifecycle("  Size: ${org.apache.commons.io.FileUtils.byteCountToDisplaySize(stagingDir.directorySize())}")
    }
}

ext.directorySize = { File dir ->
    if (!dir.exists()) return 0L
    return dir.directorySize()
}

def dockerFilesForExternalServices = [
        "elasticsearch_searchguard": "elasticsearchWithSearchGuard",
        "capture_proxy_base": "captureProxyBase",
        "k8s_config_map_util_scripts": "k8sConfigMapUtilScripts",
        "elasticsearch_client_test_console": "elasticsearchTestConsole",
        "migration_console": "migrationConsole",
        "otel_collector": "otelCollector",
        "grafana": "grafana"
]

dockerFilesForExternalServices.each { dockerImageName, projectName ->
    task("buildDockerImage_${dockerImageName}", type: DockerBuildImage) {
        if (projectName == "migrationConsole") {
            def libraries = [
                    project(":libraries:kafkaCommandLineFormatter")
            ]

            def applications = [
                    project(":CreateSnapshot"),
                    project(":MetadataMigration")
            ]
            // Setup additional sync task which doesn't depend on the base image being built, for other projects to use
            getMigrationConsoleSyncTask(project, dockerImageName, projectName, libraries, applications, false)
            def syncTask = getMigrationConsoleSyncTask(project, dockerImageName, projectName, libraries, applications, true)

            // Add config-processor staging dependency
            dependsOn stageConfigProcessor
            dependsOn syncTask
            inputDir = syncTask.destinationDir
        } else {
            inputDir = project.file("src/main/docker/${projectName}")
        }
        def hashNonce = CommonUtils.calculateDockerHash(project.fileTree(inputDir))
        images.add("migrations/${dockerImageName}:${hashNonce}".toString())
        images.add("migrations/${dockerImageName}:latest".toString())
    }
}

static Sync getMigrationConsoleSyncTask(Project project, String dockerImageName, String projectName, List<Project> libraries, List<Project> applications, boolean dependOnBaseImage) {
    // Create a single sync task to copy the required files
    def destDir = "build/docker/${dockerImageName}_${projectName}"
    def taskName = "syncArtifact_${dockerImageName}_${projectName}"
    if (!dependOnBaseImage) {
        taskName= "${taskName}_noDockerBuild"
    }
    def syncTask = project.tasks.create(taskName, Sync) {
        into destDir
        duplicatesStrategy = DuplicatesStrategy.EXCLUDE

        // Applications and Standalone Libraries both have libraries, sync them
        (libraries + applications).each { lib ->
            def applicationDestDir = "staging/${lib.name}/"

            // Ensure dependencies are resolved within the correct project context
            project.evaluationDependsOn(lib.path)

            from (lib.files { lib.configurations.runtimeClasspath }) {
                into "${applicationDestDir}/lib"
            }
            from (lib.tasks.named('jar')) {
                into "${applicationDestDir}/lib"
            }
        }

        // Sync application start scripts
        applications.each { app ->
            def applicationDestDir = "staging/${app.name}/"
            from (app.tasks.named('startScripts').get().outputs.files) {
                into "${applicationDestDir}/bin"
            }
        }

        // Sync config-processor from build directory
        from (project.file("build/docker/staging/config-processor")) {
            into "staging/config-processor"
        }

        // Sync VERSION file
        from (project.rootProject.layout.projectDirectory.file("VERSION"))

        from(project.layout.projectDirectory.dir("src/main/docker/${projectName}").asFileTree.matching {
            exclude("**/build/**", "**/.venv/**")
        })
    }

    // Collect assemble tasks from libraries and applications
    def assembleTasks = (libraries + applications).collect { it.tasks.named("assemble") }
    // Ensure the sync task depends on the assemble tasks
    syncTask.dependsOn assembleTasks

    // Add dependency on config-processor staging
    syncTask.dependsOn project.tasks.named("stageConfigProcessor")

    if (dependOnBaseImage) {
        // Migration Console base image is the test console
        syncTask.dependsOn "buildDockerImage_elasticsearch_client_test_console"
    }

    return syncTask
}

def javaContainerServices = [
        "capture_proxy": ":TrafficCapture:trafficCaptureProxyServer",
        "capture_proxy_es": ":TrafficCapture:trafficCaptureProxyServer",
        "traffic_replayer": ":TrafficCapture:trafficReplayer"
]
def baseImageOverrides = [
        "capture_proxy": "capture_proxy_base",
        "capture_proxy_es": "elasticsearch_searchguard",
]
javaContainerServices.each { dockerImageName, projectName ->
    def artifactProject = project(projectName);
    CommonUtils.copyArtifactFromProjectToProjectsDockerStaging(project as Project, artifactProject, dockerImageName)
    CommonUtils.createDockerfile(project, artifactProject, baseImageOverrides[dockerImageName], dockerFilesForExternalServices, dockerImageName)
}

javaContainerServices.forEach { dockerImageName, gradleProjectName ->
    def projectName = project(gradleProjectName).name;
    def dockerBuildDir = "build/docker/${dockerImageName}_${projectName}"
    task "buildDockerImage_${dockerImageName}"(type: DockerBuildImage) {
        dependsOn "createDockerfile_${dockerImageName}"
        inputDir = project.file("${dockerBuildDir}")
        images.add("migrations/${dockerImageName}:${version}".toString())
        images.add("migrations/${dockerImageName}:latest".toString())
    }
}

dockerCompose {
    def extensionsDir = "src/main/docker/composeExtensions/"
    useComposeFiles =
            ['src/main/docker/docker-compose.yml',
             "${extensionsDir}/" + (project.hasProperty("otel-collector") ?
                     "${project.getProperty('otel-collector')}" :
                     "otel-prometheus-jaeger.yml"),
             "${extensionsDir}" + (project.hasProperty("multiProxy") ? "proxy-multi.yml" : "proxy-single.yml")
            ]
}

task buildDockerImages {
    dependsOn buildDockerImage_k8s_config_map_util_scripts
    dependsOn buildDockerImage_elasticsearch_searchguard
    dependsOn buildDockerImage_migration_console
    dependsOn buildDockerImage_otel_collector
    dependsOn buildDockerImage_grafana
    dependsOn buildDockerImage_traffic_replayer
    dependsOn buildDockerImage_capture_proxy
    dependsOn buildDockerImage_capture_proxy_es
}

tasks.getByName('composeUp')
        .dependsOn(tasks.getByName('buildDockerImages'))