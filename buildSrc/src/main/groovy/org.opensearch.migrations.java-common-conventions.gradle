/*
 * This file was generated by the Gradle 'init' task.
 */

plugins {
    // Apply the java Plugin to add support for Java.
    id 'java'
    id 'java-test-fixtures'
}

repositories {
    mavenCentral()
    maven { url 'https://repo.jenkins-ci.org/releases/' }
}

dependencies {
    // Use JUnit Jupiter for testing.
    testImplementation libs.test.junit.jupiter
    testRuntimeOnly libs.test.junit.platform.launcher
    testImplementation testFixtures(project(":testHelperFixtures"))
}

def targetConfigs = [
    'implementation',
    'testImplementation',
    'testFixturesImplementation',
    'annotationProcessor',
    'testAnnotationProcessor',
    'testFixturesAnnotationProcessor'
]
def testOnlyConfigs = targetConfigs.findAll { it.contains("test") }
def excludedPrefixes = ['lucene.']

// 1. Define resolution configurations and avoid publishing them
configurations {
    resolvedDeps {
        canBeConsumed = false
        canBeResolved = true
    }
    resolvedTestDeps {
        canBeConsumed = false
        canBeResolved = true
        extendsFrom configurations.resolvedDeps
    }
}

// 2. Add libraries to resolution configurations
afterEvaluate {
    def libs = extensions.getByType(VersionCatalogsExtension).named("libs")

    libs.libraryAliases.each { alias ->
        if (excludedPrefixes.any { prefix -> alias.startsWith(prefix) }) return
        def dep = libs.findLibrary(alias).orElse(null)
        if (!dep) return

        def isBom = alias.startsWith("bom.") || alias.contains(".bom.")
        def configName = alias.contains("test") ? "resolvedTestDeps" : "resolvedDeps"
        if (!isBom) {
            dependencies {
                add(configName, dep)
            }
        } else {
            dependencies {
                add(configName, platform(dep.get()))
            }
        }
    }

    // 3. Resolve versions into a lookup map
    def resolved = [configurations.resolvedDeps, configurations.resolvedTestDeps].collectMany { config ->
        config.resolvedConfiguration.firstLevelModuleDependencies.collect {
            ["${it.moduleGroup}:${it.moduleName}": "${it.moduleGroup}:${it.moduleName}:${it.moduleVersion}"]
        }
    }.collectEntries()

    // 4. Apply final dependencies to real configurations (BOMs + resolved deps)
    libs.libraryAliases.each { alias ->
        if (excludedPrefixes.any { prefix -> alias.startsWith(prefix) }) return
        def dep = libs.findLibrary(alias).orElse(null)
        if (!dep) return

        def isTest = alias.contains("test")
        def isBom = alias.startsWith("bom.") || alias.contains(".bom.")
        def configsToApply = isTest ? testOnlyConfigs : targetConfigs
        def coord = "${dep.get().module.group}:${dep.get().module.name}"
        def resolvedDep = resolved[coord]

        configsToApply.each { cfg ->
            dependencies {
                if (isBom) {
                    add(cfg, platform(dep.get()))
                } else if (resolvedDep != null) {
                    add(cfg, resolvedDep)
                }
            }
        }
    }
}

tasks.named('test') {
    // Use JUnit Platform for unit tests.
    useJUnitPlatform()
}
